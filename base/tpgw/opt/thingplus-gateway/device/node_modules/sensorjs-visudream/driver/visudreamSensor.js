'use strict';
var util = require('util'),
    _ = require('lodash');

var SensorLib = require('../'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger(),
    helper = require('../helper');

var PORT_SEP = /[:]/, 
MAX_CHANNEL=24;
function VisudreamSensor(sensorInfo, options) {
  var self = this;
  Sensor.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
    switch (sensorInfo.model) {
      case 'visudreamSum':
        this.sensorDataKey = 'whr';
        break;
      case 'visudreamV':
        this.sensorDataKey = 'rmsVTotal';
        break;
      case 'visudreamI':
        this.sensorDataKey = 'rmsI';
        break;
      case 'visudreamPf':
        this.sensorDataKey = 'pf';
        break;
      case 'visudreamFreq':
        this.sensorDataKey = 'freq';
        break;
    }
  }

  if (!_.isUndefined(sensorInfo.device.address)) {
    var addrNport = sensorInfo.device.address.split(PORT_SEP);
    // address format ex) 192.168.1.99:5001 :  ip, port 5001
        
    this.host = addrNport[0] || 'localhost';
    this.port = Number(addrNport[1]) || 5001;

    logger.info('visudreamSensor sensor(addr: %s:%d) is created at driver', this.host, this.port, sensorInfo);
  } else {
    logger.error('visudreamSensor sensor address or network is not provided', sensorInfo);
  }

  this.channel = this.id && Number(_.last(this.id.split('-')));
  if (!(this.channel >= 0 && this.channel <= MAX_CHANNEL) ) {
    logger.error('visudreamSensor channel is undefined or NaN', sensorInfo);
  }

  this.dataType = _.first(VisudreamSensor.properties.dataTypes[this.model]);

  logger.debug('VisudreamSensor', sensorInfo);

  helper.init({host: this.host, port: this.port});
  helper.monitor.on('data', function (sensorData) {
    var rtn;
//TODO: cache only the last value with expire time: recommended interval, error on expire
// OPTIONAL(note recommended): introducing new property: gather all values instead of the last value
    if (sensorData instanceof Error) {
      rtn = {
        id: self.id,
        status: 'error',
        message: sensorData.message,
      };
      self.emit('data', rtn);
      return;
    }
    //check device addr
    var value = (self.channel === 0) ? sensorData[self.sensorDataKey] : 
      sensorData.channels[self.channel - 1][self.sensorDataKey];

    if (!_.isUndefined(value)) {
      rtn = {
        id: self.id,
        status: 'ok',
        result: {},
        time: {}
      };
      rtn.result[self.dataType] = value;
      rtn.time[self.dataType] = sensorData.time;
      logger.debug('[VisudreamSensor] data', rtn);
      self.emit('data', rtn);
      return;
    }
  });
}

VisudreamSensor.properties = {
  supportedNetworks: ['visudream'],
  dataTypes: { // use hash for diff types depending on model
    visudreamSum: ['power'],
    visudreamV: ['voltage'],
    visudreamI: ['current'],
    visudreamPf: ['powerFactor'],
    visudreamFreq: ['frequency'],
  },
  onChange: {
    visudreamSum: false,
    visudreamV: false,
    visudreamI: false,
    visudreamPf: false,
    visudreamFreq: false,
  },
  discoverable: false,
  recommendedInterval: {
    visudreamSum: 30000,
    visudreamV: 30000,
    visudreamI: 30000,
    visudreamPf: 30000,
    visudreamFreq: 30000,
  },
  models: ['visudreamSum', 'visudreamV', 'visudreamI',
    'visudreamPf', 'visudreamFreq'],
  idTemplate: '{gatewayId}-{deviceAddress}-{type}-{sequence}',
  category: 'sensor'
};

util.inherits(VisudreamSensor, Sensor);

VisudreamSensor.prototype._get = function (cb) {
  var self = this,
      rtn = { id: self.id};

  if (!helper.isConnected()) {
    logger.error('VisudreamSensor:not connected', self.id, self.model);

    if (cb) {
      return cb(new Error('not connected'));
    } else {
      rtn.status = 'error';
      rtn.message = 'not connected';
      self.emit('data', rtn);
      return;
    }
  }

  if (!cb) {//already data emit listener is set
    return;
  }
  
  helper.monitor.once('data', function (sensorData) {
    var rtn;

    if (sensorData instanceof Error) {
      rtn = {
        id: self.id,
        status: 'error',
        message: sensorData.message,
      };
      return cb && cb(null, rtn);
    }
    //check device addr
    var value = (self.channel === 0) ? sensorData[self.sensorDataKey] : 
      sensorData.channels[self.channel - 1][self.sensorDataKey];

    if (!_.isUndefined(value)) {
      rtn = {
        id: self.id,
        status: 'ok',
        result: {},
        time: {}
      };
      rtn.result[self.dataType] = value;
      rtn.time[self.dataType] = sensorData.time;
      logger.debug('[VisudreamSensor] data', rtn);
      return cb && cb(null, rtn);
    }
  });
};

VisudreamSensor.prototype._clear = function () {
//do nothing
};

module.exports = VisudreamSensor;
