'use strict';
var events      = require('events'),
util      = require('util'),
net      = require('net'),
_      = require('lodash'),
logger = require('log4js').getLogger('Sensor');


var DEFAULT_OPTIONS = {
  port     : 5001,
  host     : 'localhost',
  pollInterval : 10 * 1000,
},
RECONNECT_INTERVAL = 60 * 1000,
CHANNEL_NUM = 24, 
BUF_LEN = 4 + 12 + (CHANNEL_NUM * 8) * 4,
REQUEST_PACKET = new Buffer([0x10, 0x02]);

var myOptions, connection,
_isConnected = false, underConnect = false, isInitialized = false,
connectionKey;

function Monitor() {
  events.EventEmitter.call(this);
}
util.inherits(Monitor, events.EventEmitter);
var monitor = exports.monitor = new Monitor();

//func decl
var reconnect;

/**
@param {String} buf to parse
@return {Object} sensorData
      time: {Number} in ms
      freq: {Number} in hz
      rmsV: {Number} in V
      channels: {Object} values for each channel
*/
function parseSensorData(buf){
  if (!buf || buf.length !== BUF_LEN) {
    return;
  }

  //buf and offset are in outer scope
  function readValue(belowFP) {
    var v = buf.readInt32LE(offset);
    offset += 4;
    return v ? v / (belowFP || 1) : 0;
  }
  function channelRead(type, belowFP) {
    _.each(sensorData.channels, function (v) {
      v[type] = readValue(belowFP);
    });
  }

  var sensorData = {}, offset = 0;
  sensorData.channels = new Array(CHANNEL_NUM);
  _.each(sensorData.channels, function (v, i) {
    sensorData.channels[i] = {};
  });

  sensorData.time = _.now();
  sensorData.freq = readValue(100);
  sensorData.rmsV = {};
  sensorData.rmsV.a = readValue(1000);
  sensorData.rmsV.b = readValue(1000);
  sensorData.rmsV.c = readValue(1000);
  sensorData.rmsVTotal = sensorData.rmsV.a + sensorData.rmsV.b + sensorData.rmsV.c;
  channelRead('rmsI', 10000);
  channelRead('pf', 10);
  channelRead('sumPower15', 100);
  channelRead('sumPower60', 100);
  channelRead('va', 10000);
  channelRead('var', 10000);
  channelRead('watt', 10000);
  channelRead('whr', 100); //kwh
  //total whr assuming summation of 1/2/3 channels
  sensorData.whr = (sensorData.channels[0].whr || 0) + 
                  (sensorData.channels[1].whr || 0) + 
                  (sensorData.channels[2].whr || 0);
  return sensorData;
}

function initConnection(cb) {
  if (underConnect) {
    return cb && cb(new Error('underConnect'));
  }
  if (_isConnected) {
    return cb && cb(); //already connected
  }

  logger.info('[helper] myOptions', myOptions);
  underConnect = true;
  connection.connect(myOptions.port, myOptions.host, function (err) {
    underConnect = false;
    if (err) {
      logger.error('error connecting: ' + err.stack);
      _isConnected = false;
      return cb && cb(err);
    }

    logger.info('connected success', myOptions);
    _isConnected = true;
    return cb && cb(err);
  });
}

function getSensorData(cb) {
  if (!_isConnected) {
    reconnect();
    return cb && cb(new Error('not connected'));
  }
  connection.write(REQUEST_PACKET);
  connection.once('data', function (buf) {
    var sensorData = parseSensorData(buf);
    return cb && cb(null, sensorData);
  });
}

//TODO: support multiple devices. aasumign only one device for now.
function init(opts, cb) {
  var key;

  myOptions = _.defaults(opts || {}, DEFAULT_OPTIONS);
  key = [myOptions.host, myOptions.port].join(':');
  if (isInitialized) {
    if (connectionKey === key) { 
      return cb && cb();
    } else {
      return cb && cb(new Error('no new connection:' + key));
    }
  }
  connectionKey = key;
  isInitialized = true;

  connection = new net.Socket();
  connection.on('error', function() {
    _isConnected = false;
    connection.destroy();
    logger.error('[helper] conn error');
  });
  connection.on('close', function () {
    _isConnected = false;

    logger.error('[helper] conn close');
  });

  return initConnection(function () {
    var polling = function () {
      getSensorData(function (err, sensorData) {
        setTimeout(polling, myOptions.pollInterval);
        if (err || !sensorData) {
          logger.error('getSensorData is null or err', err);
          return;
        }
        monitor.emit('data', sensorData);
        logger.debug('[getSensorData] emit data', JSON.stringify(sensorData));
      });
    };
    polling();
    return cb && cb(); // ignore error
  });
}


function finConnection() {
  _isConnected = false;
  underConnect = false;
  connection.end();
  connection.destroy();
}

reconnect = _.throttle(function() {
  if (_isConnected) {
    return;
  } else {
    finConnection();
    initConnection();
  }
}, RECONNECT_INTERVAL, {trailing: false});

function isConnected() {
  return _isConnected;
}

exports.init = init;
exports.monitor = monitor;
exports.isConnected = isConnected;

//run directly from node, example:
if (require.main === module) {
  init({host: '112.218.213.44', port: 50000}, function (err) {
    logger.warn('init done', err);
  });
}
