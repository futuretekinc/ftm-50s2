'use strict';

var util = require('util'),
EventEmitter = require('events').EventEmitter,
jsonrpc = require('jsonrpc-tcp'),
_ = require('lodash');

var logger = require('log4js').getLogger('Sensor');

//constants
var JSONRPC_PORT = 50800,
KEEP_ALIVE_TIME = 30000,
MAX_INIT_TIME = 3000;

function RpcHelper() {
  EventEmitter.call(this);
  this._initializing = false;
  this._initialized = false;
  this._connected = false; //TODO: use connected!
}

util.inherits(RpcHelper, EventEmitter);

RpcHelper.prototype.call = function() {
  var self = this, cb = _.last(arguments), callArgs = arguments;

  logger.debug('[jsonrpcConnMgr] call initialize & remote', self._initialized, !!self.remote);
  if (self._initialized && self.remote) {
    self.remote.call.apply(self.remote, callArgs);
  } else {
    if (!self._initialized) {
      self.init();
    } 

    setTimeout(function () {
      if (self._initialized && self.remote) {
        self.remote.call.apply(self.remote, callArgs);
      } else {
        logger.error('[jsonrpcConnMgr]init timeout');
        return _.isFunction(cb) && cb(new Error('not connected'));
      }
    }, MAX_INIT_TIME);
  }
};
RpcHelper.prototype.finalize = function() {
  var self = this;
  if (self.client) {
    self.client.end();
  }
  if (self.keepAliveTimer) {
    clearInterval(self.keepAliveTimer);
    delete self.keepAliveTimer;
  }
  delete self.remote;
  if (self._initializing) {
    self._initialized = false;
    self._initializing = false;
  }
  logger.warn('[jsonrpcConnMgr] finClient');
};

//TODO: get device address from sensor id, caching divice discovery db.
//TODO: secure connection, authenticate 
RpcHelper.prototype.init = function() {
  var self = this;

  if (self._initialized) {
    logger.warn('[jsonrpcConnMgr] already initialized');
    return;
  }
  if (self._initializing) {
    logger.warn('[jsonrpcConnMgr] under initializing');
    return;
  }

  self._initializing = true;

  logger.info('[jsonrpcConnMgr] init');
  if (!self.client) {
    self.client = jsonrpc.createClient();
  }
  self.client.connect(JSONRPC_PORT);
  self.client.on('error', function () {
    self._isConnAlive = false;
    logger.error('[jsonrpcConnMgr] client error');
    self.client.end();
    delete self.remote;
    if (self._initializing) {
      self._initialized = true;
      self._initializing = false;
    }
  });
  self.client.on('close', function () {
    self._isConnAlive = false;
    logger.error('[jsonrpcConnMgr] client close');
    delete self.remote;
    if (self._initializing) {
      self._initialized = true;
      self._initializing = false;
    }
    self.emit('disconnect');
  });
  self.client.on('request', function() {
    self._isConnAlive = true;
  });
  self.client.on('response', function() {
    self._isConnAlive = true;
  });
  self.client.on('notification', function(noti) {
    self._isConnAlive = true;
    if (noti.method !== 'sensor.notification') {
      logger.warn('notification: method is not sensor.notification', noti);
    }
    self.emit('notification', noti.params[0], noti.params[1]);
  });
  self.client.on('connect', function(remote) {
    self._isConnAlive = true;
    logger.info('[jsonrpcConnMgr] client connect');
    self.remote = remote;
    if (self._initializing) {
      self._initialized = true;
      self._initializing = false;
    }
    self.emit('connect');
  }); 
  self.keepAliveTimer = setInterval(function () {
    if (!self._isConnAlive && 
        self._initialized) {
      self.call('ping', function (err, result) {
        logger.debug('ping', err, result);
        if (err && err !== 'Method Not Found, method=ping') { //allowing not implmented case
          self.client.end();
          self.client.connect(JSONRPC_PORT);
        } else {
          self._isConnAlive = true;
        }
      });
    }
    self._isConnAlive = false;
  }, KEEP_ALIVE_TIME);

  return;
};

module.exports = new RpcHelper();
