'use strict';

var util = require('util'),
    snmp = require ('net-snmp'),
    snmpParser = require('snmp-native'),
    async = require ('async'),
    dgram = require('dgram'),
    _ = require ('lodash'),
    LRU = require('lru-cache');

var Device = require('../../index').Device,
    Network = require('../../index').Network,
    logger = Network.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

var INIT_DELAY_TIME = 4000, INIT_WAIT_TIME = 6000, ONE_SEC=1000;

//devices cache has active devices: maxage 3min, polling 1min 
var _devices = LRU({
  maxAge: cfg.SCAN_INTERVAL * 3,
  dispose: function (addr, device) {  
    //FIXME: this called even on set()
    if (device.__doNotRemove) { 
      device.__doNotRemove = false;
      logger.debug('future:cache disposed: do not just after set() for update', addr);
    } else {
      device.removeAllListeners(); 
      logger.info('future:cache disposed: device', addr);
    }
  },
}),
_initializing,
_initialized;

var init; // function

function Future(options) {
  Network.call(this, 'future', options);
}

util.inherits(Future, Network);

Network.prototype.getDevice = function (addr, options, cb) {
  var self = this;
  if (_.isFunction(options)) {
    cb = options;
  }
  function _getDevice() {
    var device = _devices.peek(addr);
    logger.debug('getDevice', addr, device);
    return cb && cb(undefined, device);
  }
  if (_initialized) {
    _getDevice();
  } else {
    init(self, _getDevice);
  }
};
/*
 * @param targetIP {String}  device ip
 * @param macAddr {String} mac address of discovered device
 * @param oids {Array} oid list
 * @param cb {Function} call back
 */
function retrieveDeviceInfo(targetIp, macAddr, oids, cb) {
  var sensorInfos = [],
      session = snmp.createSession(targetIp, 'public', cfg.SNMP_OPTIONS);

  async.waterfall([
    function (done) { // get sensors #
      //check oids provided
      if (!_.all(oids, function (oid) {
        return !!_.find(cfg.SENSOR_OIDS, {baseOid: oid});
      })) {
        return done(new Error('unknown oids:' + oids));
      }
      
      var countOids = _.map(oids, function(v) {return v + '.' + cfg.COUNT_OID;}),
          ids = [], i;
      snmpHelper.getSNMP(session, countOids, function (err, result) {
        if (err) { return done(err); }
        _.each(result && oids, function (baseOid) {
          var count = result[baseOid + '.' + cfg.COUNT_OID];
          for(i=0; i < count; i++) {
            ids.push([baseOid, cfg.ID_OID, (i+1)].join('.'));
          }
        });
        return done(null, ids);
      });
    },
    function (ids, done) { // get sensor types
      snmpHelper.getSNMP(session, ids, function (err, result) {
        _.each(result, function (serial, oid) {
          var sensor = _.find(cfg.SENSOR_OIDS, function (v) {
            return oid && oid.indexOf(v.baseOid) === 0; 
          });
          if (!sensor) {
            logger.error('future:retrieveDeviceInfo no sensor ', serial, oid);
            return; //continue
          } 
          logger.debug('retrieveDeviceInfo oid', oid, 'id', result[oid].toString());
          sensorInfos.push({
            id: [macAddr, result[oid].toString()].join('-'),
            oid: oid,
            model: sensor.model,
            device: {
              sensorNetwork: 'future',
              address: macAddr
            }
          });
        });
        logger.debug('found sensors', sensorInfos);
        if (!err && _.isEmpty(sensorInfos)) {
          logger.error('future:retrieveDeviceInfo no sensors', targetIp, macAddr);
          err = new Error('no sensor infos');
        }
        return done(err);
      });
    }
    ], function (err) {
    try {
      session.close();
    } catch(e) {
      logger.error('[network/future] error on closing session', e);
    }

    if (err) {
      return cb && cb(err);
    } else {
      return cb && cb(err, macAddr, sensorInfos);
    }
  });
}

var bcastClient;
function startScanning(self, cb) {
  var hello = new Buffer('Hello?');
  bcastClient = dgram.createSocket('udp4');

  try {
    bcastClient.bind(cfg.SNMP_TRAP_PORT);
    bcastClient.on('listening', function () {
      bcastClient.setBroadcast(true);
      logger.debug('[future:scan]bound SNMP_TRAP_PORT');
    });
    bcastClient.on('message', function(msg, rinfo) {
      var targetIp = rinfo && rinfo.address,
      parsedMsg, startTime, discoveryMsg, alertMsg;

      try {
        parsedMsg = snmpParser.parse(msg);
        logger.debug('Parse: ', parsedMsg);
      } catch (e) {
        logger.error('snmp parse exp', e);
        return;
      }

      _.each(parsedMsg.pdu.varbinds, function (vb) {
        var oid = vb.oid && vb.oid.join('.');
        switch (oid) {         
        case cfg.UPTIME_OID:
          startTime = _.now() - (vb.value * 10);
          logger.debug ('startTime = ', new Date(startTime));
          break;
        case cfg.DISCOVERY_MSG_OID:
          try {
            //"id" : "00145....",
            //"mac" : "00405c123456",
            //oids: [ "1.3.6.1.4.1.42251.3.1281", ... ]
            discoveryMsg = JSON.parse(vb.value); 
            if (discoveryMsg.mac) {
              discoveryMsg.mac = discoveryMsg.mac.replace(/:/g,'').toLowerCase();
            }
            logger.info('discovery msg', discoveryMsg);
            retrieveDeviceInfo(targetIp, discoveryMsg.mac, _.map(discoveryMsg.oids, function (v){
                return cfg.BASE_OID + '.' + v;
              }), function (err, addr, sensorInfos) {
              var device;
              if (!err && addr) {
                device = _devices.get(addr);
                if (device) {
                  //any change in extraInfo
                  device.__doNotRemove = true; // this is just for update
                  _devices.set(addr, device);
                  logger.debug('future:cache update device', addr);
                  if (!device.extraInfo || 
                    device.extraInfo.deviceId !== discoveryMsg.PID ||
                    device.extraInfo.ipAddr !== targetIp ||
                    Math.abs(device.extraInfo.startTime - startTime) > 3*1000/*3s*/) {
                    logger.error('future:cache extraInfo changed: before', addr, device.extraInfo);
                    device.extraInfo = { ipAddr: targetIp, startTime: startTime,
                        deviceId: discoveryMsg.PID, sensorInfos: sensorInfos};
                    logger.error('future:cache extraInfo changed: after', addr, device.extraInfo);
                  }
                } else {
                  //FIXME: create snmp session here and share all sensors of the device
                  device = new Device(self, addr, sensorInfos);
                  device.extraInfo = { ipAddr: targetIp, startTime: startTime, 
                      deviceId: discoveryMsg.PID, sensorInfos: sensorInfos};
                  _devices.set(addr, device);
                  //request from sensor driver
                  device.on('enableChange', function(/*oid*/) {
                    var setVarbind = {
                      oid: cfg.TRAP_ADD_OID,
                      type: snmp.ObjectType.OctetString,
                      value: snmpHelper.getLocalAddr(targetIp), //FIXME: check null?
                    },
                    session = snmp.createSession(targetIp, 'public', cfg.SNMP_OPTIONS);
                    logger.debug('setVarBind', {
                      oid: cfg.TRAP_ADD_OID,
                      type: snmp.ObjectType.OctetString,
                      value: snmpHelper.getLocalAddr(targetIp), //FIXME: check null?
                    });
                    //FIXME: check existing values before set
                    snmpHelper.setSNMP(session, [setVarbind], function (err, result) {
                      if (err) {
                        logger.error('[network/future] failure to enableChange', err, result);
                      }
                      try {
                        session.close();
                      } catch(e) {
                        logger.error('[network/future] error on closing setSNMP session', e);
                      }
                    });
                  });
                  logger.warn('future:cache set found device', device.address, 
                              device.sensorUrls, device.extraInfo);
                }
              } else {
                logger.error('future:cache get device error', addr, err);
                if (addr) {
                  _devices.del(addr);
                  logger.error('future:cache del device:', addr);
                }
              }
            });
          } catch (e) {
            logger.error('discovery msg: malformat', e, discoveryMsg);
          }
          break;
        case cfg.ALERT_MSG_OID:
          try {
            alertMsg = JSON.parse(vb.value); 
            logger.debug('alert msg', alertMsg, targetIp);
            _.each(_devices.values(), function (device) {
              if (device.extraInfo && device.extraInfo.ipAddr === targetIp) {
                device.emit('change', alertMsg);
                return false;
              }
            });
          } catch (e) {
            logger.error('alert msg: malformat');
          }
          break;
        default:
          logger.debug ('unknown ', oid, '=', vb.value);
        }
      });
    });

    _.each(_.pluck(cfg.NET_IF_LIST, 'bcast'), function (addr) { 
      bcastClient.send(hello, 0, hello.length, cfg.SCAN_PORT, addr);
    });
    setTimeout(function () { //send one more time considering loss
      _.each(_.pluck(cfg.NET_IF_LIST, 'bcast'), function (addr) { 
        bcastClient.send(hello, 0, hello.length, cfg.SCAN_PORT, addr);
      });
    }, 500);
    setInterval(function () {
      _.each(_.pluck(cfg.NET_IF_LIST, 'bcast'), function (addr) {
        bcastClient.send(hello, 0, hello.length, cfg.SCAN_PORT, addr);
      });
    }, cfg.SCAN_INTERVAL);

    return cb && cb();
  } catch (e) {
    logger.error('future:scan err=', e);
    bcastClient.close();
    return cb && cb(e);
  }
}

Future.prototype.discover = function (driverOrModel, cb) {
  var self = this;

  if (_.isFunction(driverOrModel)) {
    cb = driverOrModel;
    driverOrModel = undefined;
  }

  function _discover() {
    if (cb) {
      cb(undefined, _devices.values());
    } else {
      _.each(_devices.values(), function (device) {
        self.emit('discovered', device);
      });
      self.emit('done');
    }
  }
  if (_initialized) {
    _discover();
  } else {
    init(self, _discover);
  }
};

init = function init(self, cb) {
  if (_initialized) {
    return cb && cb();
  }
  if (_initializing && cb) {// max 5secs waiting 
    var tries = INIT_WAIT_TIME/ONE_SEC, timer = setInterval(function () {
      tries--;
      if (_initialized) {
        clearInterval(timer);
        return cb();
      } else if (tries < 0) {
        clearInterval(timer);
        return cb(new Error('init lasts too long'));
      }
    }, ONE_SEC);
  }

  _initializing = true;

  async.series([
    function (done) { // get broadcast addrs
      snmpHelper.initNetIfList(function (err) {
        if (!err) {
          logger.info('future:bcastAddrs', _.pluck(cfg.NET_IF_LIST, 'bcast'));
        }
        return done(err);
      });
    },
    function (done) {
      startScanning(self, function (err) {
        return done(err);
      });
    },
    function (done) {
      setTimeout(function () {
        return done();
      }, INIT_DELAY_TIME);
    },
  ], function (err) {
    if (err) {
      logger.fatal('future:network init failure', err);
      return;
    }
    _initialized = true;
    _initializing = false;
    logger.info('future:network init done');
    return cb && cb();
  });
};

module.exports = new Future();
