'use strict';

var snmp = require ('net-snmp'),
    _ = require ('lodash'),
    exec = require('child_process').exec;

var logger = require('log4js').getLogger('Sensor');

var config = {};

config.SNMP_TRAP_PORT = 162;
config.SCAN_PORT = 1234;
config.SCAN_INTERVAL = 60 * 1000; //1min
config.MAC_OID = '1.3.6.1.4.1.42251.1.2.2.0'; // mac address
config.UPTIME_OID = '1.3.6.1.2.1.1.3.0'; // uptime in broadcast resp
config.DISCOVERY_MSG_OID = '1.3.6.1.4.1.42251.1.100.2.1.0';
config.ALERT_MSG_OID = '1.3.6.1.4.1.42251.1.100.2.2.0';
config.TRAP_ADD_OID = '1.3.6.1.4.1.42251.1.100.1.3.0';
config.COUNT_OID = '1.0';
config.ID_OID = '2.1.1';
config.VALUE_OID = '2.1.6';
config.BASE_OID = '1.3.6.1.4.1.42251.1.3';
config.SENSOR_OIDS = [
  {
    model: 'futureDi',
    driver: 'futureSensor',
    baseOid: '1.3.6.1.4.1.42251.1.3.1280',
  },{
    model: 'futureTemp',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.256',
  },{
    model: 'futureHumi',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.512',
  },{
    model: 'futureGas',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.1792',
  },{
    model: 'futurePower',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.2048',
  },{
    model: 'futureDust',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.2562',
  },{
    model: 'futureCountEvent',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.2816',
  },{
    model: 'futureVoltage',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.768',
  },{
    model: 'futureCurrent',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.1024',
  },{
    model: 'futurePressure',
    driver: 'futureSensor',
    baseOid:   '1.3.6.1.4.1.42251.1.3.3072',
  }, {
    model: 'futureDo',
    driver: 'futureActuator',
    baseOid:   '1.3.6.1.4.1.42251.1.3.1536',
  },{
    model: 'futureTempCtrl',
    driver: 'futureActuator',
    baseOid:   '1.3.6.1.4.1.42251.1.3.32512',
  }
];
config.SNMP_OPTIONS = {
  version: snmp.Version2 // version 1?
};
config.NET_IF_LIST = null;

//get bcast addresse of each ntework interface.
function initNetIfList(cb) {
  /*jshint bitwise: false*/
  if (config.NET_IF_LIST) {
    return cb && cb(null, config.NET_IF_LIST);
  }
  exec('ifconfig', function (err, ifconfig) {
    var ifs = {};
    _.each(ifconfig.split('\n\n'), function (netIf) {
      var rtn = /^(\S+)[\S\s]+HWaddr\s(\S+)[\S\s]+inet\saddr:(\S+)[\S\s]+Mask:(\S+)/.exec(netIf);
      if (rtn && rtn[1] && rtn[1] !== 'lo') {
        var
            ifName = rtn[1],
            mac= rtn[2] && rtn[2].replace(/:/g,'').toLowerCase(),
            addr = rtn[3],
            subnet = rtn[4],
            bcast;

        var addrArr =  addr && addr.split('.').map(function(x) { return Number(x); }),
            subnetArr = subnet && subnet.split('.').map(function(x) { return Number(x); });

        bcast = _.map(addrArr, function (x, idx) {
          return x | (subnetArr[idx] ^ 0xff);
        }).join('.');
        ifs[ifName] = {
          mac:mac,
          addr: addr,
          subnet: subnet,
          bcast: bcast,
        };
      }
    });
    config.NET_IF_LIST = ifs;
    return cb && cb(null, ifs);
  });
}

function getLocalAddr(remoteIp) {
  /*jshint bitwise: false*/
  var foundIf;
  _.each(config.NET_IF_LIST, function (netIf) {
    var addrArr =  remoteIp.split('.').map(function(x) { return Number(x); }),
    subnetArr = netIf.subnet.split('.').map(function(x) { return Number(x); });

    var bcast = _.map(addrArr, function (x, idx) {
      return x | (subnetArr[idx] ^ 0xff);
    }).join('.');
    if (bcast === netIf.bcast) {
      foundIf = netIf;
      return false;
    }
  });

  if (foundIf) {
    return foundIf.addr;
  } else {
    return null;
  }
}

function getSNMP(session, oids, cb) {
  var result = {};
  if (!_.isArray(oids)) {
    oids = [oids];
  }
  session.get(oids, function (err, varbinds) {
    var req;

    if (varbinds instanceof Error) {
      req = err;
      err = varbinds;
      varbinds = undefined;
    }

    if (err) {
      logger.error ('future:get err oids=%j err=', oids, err, new Error());
      return cb && cb(err);
    }
    _.each(varbinds, function (varbind) {
      if (snmp.isVarbindError(varbind)) {
        logger.error('future:get varbind error', snmp.varbindError(varbind));
      } else{
        logger.debug(varbind.oid + ' = ' + varbind.value);
        result[varbind.oid] = varbind.value;
      }
    });
    return cb && cb(null, _.isEmpty(result) ? undefined : result);
  });
}
function setSNMP(session, varbinds, cb) {
  var result = {};
  session.set(varbinds, function (err, varbinds) {
    var req;

    if (varbinds instanceof Error) {
      req = err;
      err = varbinds;
      varbinds = undefined;
    }

    if (err) {
      logger.error ('future:set err oids=%j err=', varbinds, err, new Error());
      return cb && cb(err);
    }
    _.each(varbinds, function (varbind) {
      if (snmp.isVarbindError(varbind)) {
        logger.error('future:set varbind error', snmp.varbindError(varbind));
      } else{
        logger.debug(varbind.oid + ' = ' + varbind.value);
        result[varbind.oid] = varbind.value;
      }
    });
    return cb && cb(null, _.isEmpty(result) ? undefined : result);
  });
}


exports.setSNMP = setSNMP;
exports.getSNMP = getSNMP;
exports.getLocalAddr = getLocalAddr;
exports.initNetIfList = initNetIfList;
exports.config = config;

initNetIfList(); // get interfaces one time on load
