'use strict';

var util = require('util');

var SensorLib = require('../index'),
    rpcHelper = require('../rpcHelper'),
    _ = require('lodash'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger(),
    RateLimiter = require('limiter').RateLimiter;

function JsonrpcSensor(sensorInfo, options) {
  Sensor.call(this, sensorInfo, options);

  var self = this;
  if (!this.device.address) {
    logger.fatal('[JsonrpcSensor] no device address', sensorInfo);
    //FIXME: throw error
    return;
  }
  
  this.shortId = this.id.substr(this.id.indexOf('-')+1);

  rpcHelper.init();

  this.options =  _.defaults(options || {}, sensorInfo.options);
  if (!JsonrpcSensor.properties.onChange[self.model] && //not event
    this.options && 
    (this.options.notification === true||this.options.notification === 'true')) {
    this._enableLog();
    this.isNotification = true;
  }

  this.limiter = new RateLimiter(JsonrpcSensor.properties.rateLimit || 10, 'minute', true);  // fire CB immediately

  rpcHelper.on('connect', function () {
    if (self.logListener) { self._enableLog(); }
    if (self.changeListener) { self._enableChange(); }
  });
  rpcHelper.on('disconnect', function () {
    var rtn = {status: 'off', id : self.id};
    rtn.message = 'disconnected';
    if (self.logListener) { self.emit('data', rtn); }
    if (self.changeListener) { self.emit('change', rtn); }
    logger.error('[JsonrpcSensor] no connection');
    return;
  });
  
  logger.debug('[JsonrpcSensor]', sensorInfo);
}

JsonrpcSensor.properties = {
  supportedNetworks: ['jsonrpc'],
  dataTypes: {
    'jsonrpcTemp' : ['temperature'],
    'jsonrpcHumi' : ['humidity'],
    'jsonrpcLight': ['light'],
    'jsonrpcNoise': ['noise'],
    'jsonrpcDi': ['onoff'],
    'jsonrpcMotion': ['motion'],
    'jsonrpcCo2': ['co2'],
    'jsonrpcCo': ['co'],
    'jsonrpcVoc': ['voc'],
    'jsonrpcPower': ['power'],
    'jsonrpcDust': ['dust'],
    'jsonrpcCount': ['count'],
    'jsonrpcCountEvent': ['countEvent'],
    'jsonrpcVoltage': ['voltage'],
    'jsonrpcWeight': ['weight'],
    'jsonrpcColor': ['color'],
    'jsonrpcVibration': ['vibration'],
    'jsonrpcSpeed': ['speed'],
    'jsonrpcAccelerometer': ['accelerometer'],
    'jsonrpcString': ['string'],
    'jsonrpcPressure': ['pressure']
  },
  onChange: {
    jsonrpcTemp: false,
    jsonrpcHumi: false,
    jsonrpcLight: false,
    jsonrpcNoise: false,
    jsonrpcDi: true,
    jsonrpcMotion: true,
    jsonrpcCo2: false,
    jsonrpcCo: false,
    jsonrpcVoc: false,
    jsonrpcPower: false,
    jsonrpcDust: false,
    jsonrpcCount: false,
    jsonrpcCountEvent: true,
    jsonrpcVoltage: false,
    jsonrpcWeight: false,
    jsonrpcColor: false,
    jsonrpcVibration: false,
    jsonrpcSpeed: false,
    jsonrpcAccelerometer: false,
    jsonrpcString: false,
    jsonrpcPressure: false,
  },
  discoverable: true,
  addressable: false, //given manually as param
  recommendedInterval: 30000,
  rateLimit: 10, // per minute
  maxInstances: 1,
  idTemplate: '{gatewayId}-{deviceAddress}-{type}-{sequence}',
  models: [ 'jsonrpcTemp', 'jsonrpcHumi', 'jsonrpcLight', 'jsonrpcNoise', 'jsonrpcDi',
    'jsonrpcMotion', 'jsonrpcCo2', 'jsonrpcCo', 'jsonrpcVoc', 'jsonrpcPower',
    'jsonrpcDust', 'jsonrpcCount', 'jsonrpcCountEvent', 'jsonrpcVoltage',
    'jsonrpcWeight', 'jsonrpcColor', 'jsonrpcVibration', 'jsonrpcSpeed',
    'jsonrpcAccelerometer', 'jsonrpcString',
    'jsonrpcPressure'],
  category: 'sensor'
};

util.inherits(JsonrpcSensor, Sensor);

JsonrpcSensor.prototype._get = function () {
  var self = this; 

  if (self.isNotification) { return; } //skip on log enabled
  
  rpcHelper.call('sensor.get', self.shortId, function (err, result) {
    var rtn = {status: 'error', id : self.id};

    if (err || !result) {
      // FIXME: not to be here
      rtn.message = err ? err.message : 'no result';
      self.emit('data', rtn);
      logger.error('[JsonrpcSensor] no connection', err, result);
      return;
    }
    var type = JsonrpcSensor.properties.dataTypes[self.model][0];

    if (!_.isUndefined(result.value)) {
      rtn.status = 'ok';
      rtn.result = {};
      rtn.result[type] = result.value;
      if (result.time) {
        rtn.time = {};
        rtn.time[type] = result.time;
      }
    } else {
      if (result.status === 'on') {
        rtn.message = 'on';
        rtn.status = 'ok';
      } else if (result.status === 'off') {
        rtn.message = 'off';
        rtn.status = 'off';
      } else {
        rtn.message = (result.message) ? result.message : 'invalid value';
      }
    }
    self.emit('data', rtn);
    return;
  });
};

JsonrpcSensor.prototype._enableLog = function () {
  var self = this;

  if (!JsonrpcSensor.properties.onChange[self.model]) {
    logger.debug('JsonrpcSensor:_enableLog');
    rpcHelper.call('sensor.setNotification', self.shortId, function (err) {
      if (err) {
        throw new Error('enable log failure');
      }
    });
    if (!self.logListener) {
      self.logListener = function (id, val) {
        var rtn = {status: 'error', id : self.id},
        type = JsonrpcSensor.properties.dataTypes[self.model][0];

        if (self.shortId !== id) { return; }

        self.limiter.removeTokens(1, function(err, remainingRequests) {
          if (remainingRequests < 0) {
            rtn.message = 'limiting';
            return self.emit('data', rtn);
          } 
            
          if (val && !_.isUndefined(val.value)) {
            rtn.status = 'ok';
            rtn.result = {};
            rtn.result[type] = val.value;
            if (val.time) {
              rtn.time = {};
              rtn.time[type] = val.time;
            }
          } else {
            if (val && val.status === 'on') {
              rtn.message = 'on';
              rtn.status = 'ok';
            } else if (val && val.status === 'off') {
              rtn.message = 'off';
              rtn.status = 'off';
            } else {
              rtn.message = (val && val.message) ? val.message : 'invalid value';
            }
          }
          self.emit('data', rtn);
          return;
        });
      };
      rpcHelper.on('notification', self.logListener);
    }
  } else {
    throw new Error('enable change for event');
  }
};
JsonrpcSensor.prototype._enableChange = function () {
  var self = this;

  if (JsonrpcSensor.properties.onChange[self.model]) {
    logger.debug('JsonrpcSensor:_enableChange');
    rpcHelper.call('sensor.setNotification', self.shortId, function (err) {
      if (err) {
        throw new Error('enable change failure');
      }
    });
    if (!self.changeListener) {
      self.changeListener = function (id, val) {
        var rtn = {status: 'error', id : self.id},
        type = JsonrpcSensor.properties.dataTypes[self.model][0];

        if (self.shortId !== id) { return; }

        self.limiter.removeTokens(1, function(err, remainingRequests) {
          if (remainingRequests < 0) {
            rtn.message = 'limiting';
            return self.emit('change', rtn);
          } 

          if (val && !_.isUndefined(val.value)) {
            rtn.status = 'ok';
            rtn.result = {};
            rtn.result[type] = val.value;
            if (val.time) {
              rtn.time = {};
              rtn.time[type] = val.time;
            }
          } else {
            if (val && val.status === 'on') {
              rtn.message = 'on';
              rtn.status = 'ok';
            } else if (val && val.status === 'off') {
              rtn.message = 'off';
              rtn.status = 'off';
            } else {
              rtn.message = (val && val.message) ? val.message : 'invalid value';
            }
          }
          self.emit('change', rtn);
          return;
        });
      };
      rpcHelper.on('notification', self.changeListener);
    }
  } else {
    throw new Error('enable change for non-event');
  }
};
JsonrpcSensor.prototype._clear = function () {
  var self = this;
  logger.warn('[JsonrpcSensor] _clear', this.ipAddr);
  if (self.changeListener) {
    rpcHelper.removeListener('notification', self.changeListener);
    delete self.changeListener;
  }
  if (self.logListener) {
    rpcHelper.removeListener('notification', self.logListener);
    delete self.logListener;
  }
  return;
};

module.exports = JsonrpcSensor;
