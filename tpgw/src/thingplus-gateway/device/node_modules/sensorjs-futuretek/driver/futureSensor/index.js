'use strict';
var util = require('util'),
    _ = require('lodash'),
    snmp = require ('net-snmp');

var SensorLib = require('../../index'),
    Sensor = SensorLib.Sensor,
    logger = Sensor.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

var DI_POLLING_INTERVAL = 60000, // 1min , for status check
REPORT_INTERVAL = 1 * 60000, // 1min
THROTTLE_INTERVAL = 60 * 1000;

function chkSession(self, cb) {
  var network = self.info && self.info.device && 
                self.info.device.sensorNetwork &&
                SensorLib.getNetwork(self.info.device.sensorNetwork),
      prevIp = self.ip;
  
  if (!network || !self.info.device.address) {
    logger.error('futureSensor:chkSession invalid device info', self.info);
    return cb && cb(new Error('invalid device info'));
  }
  network.getDevice(self.info.device.address, function (err, device) {
    var si;
    self.ip = device && device.extraInfo && device.extraInfo.ipAddr;

    if (!self.ip) {
      logger.error('futureSensor:chkSession missing device', self.info);
      return cb && cb(new Error('missing device'));
    }

    if (device && self.device !== device) { //device changed
      self.device = device;
    }

    si = _.find(device.extraInfo && device.extraInfo.sensorInfos, {id: self.id});
    if (si && si.oid) {
      self.oidIdx = Number(si.oid.substring(si.oid.lastIndexOf('.')+1));
    } 
    if (!si || ((self.oidIdx !==0) && !self.oidIdx)) {
      logger.error('futureSensor: cannot find sensorinfo', self.id, self.oid);
    }

    //if enableChanged && dataListener is not set
    if (self.enableChange &&
       (!self.dataListener || 
        _.indexOf(self.device.listeners('change'), self.dataListener) === -1)) {
      self.dataListener = function(msg) {
        var result = {}, value;
        logger.debug('futureSensor:checkSession dataListener', msg, self.oid);
        if (self.oid === msg.id) {
          value = msg.value; // FIXME: use msg.Time?, correct server 
          if (value === 'ON') {
            value = 1;
          } else if (value  === 'OFF') {
            value = 0;
          }
          result[self.dataType] = value;
          self.emit('change', {
            id: self.id,
            status: 'ok',
            result: result,
          });
          self._cached.value = result[self.dataType];
          self._cached.time = _.now();
          logger.debug('futureSensor:emit',{ 
            id: self.id,
            status: 'ok',
            result: result,
          }); 
        }
      };
      device.on('change', self.dataListener);
      device.emit('enableChange', self.oid);
    }

    if (self.ip === prevIp && self.session) {//no ip change keep session
      return cb && cb();
    } else { 
      if (self.session) {
        self.session.close();
        delete self.session;
      }
      self.session = snmp.createSession(self.ip, 'public', cfg.SNMP_OPTIONS);
      logger.warn('futureSensor:chkSession new session:', self.id, self.ip);
      return cb && cb();
    }
  });
}

function FutureSensor(sensorInfo, options) {
  Sensor.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }

  logger.debug('FutureSensor', sensorInfo);

  var self = this;
  this.oidIdx = parseInt(this.id.slice(-2), 16); // FIXME: last 2 disits from id
  this.oid = this.id.slice(-8); 
  var sensor = _.find(cfg.SENSOR_OIDS, {model: this.model});
  this.valueOid = sensor &&
    [sensor.baseOid, cfg.VALUE_OID, this.oidIdx].join('.');

  this.dataType = _.first(FutureSensor.properties.dataTypes[this.model]);

  this._cached = {value: -1, time: -1, retries: 0};
  this.throttledChkSession = _.throttle(_.partial(chkSession, this), 
            THROTTLE_INTERVAL, {trailing: false});
  this.throttledChkSession();

  //polling until first session being established.
  function pollingFirstSession() {
    setTimeout(function () {
      if (!self.session) {
        chkSession(self);
        pollingFirstSession();
      }
    }, THROTTLE_INTERVAL);
  }
  pollingFirstSession();
}


FutureSensor.properties = {
  supportedNetworks: ['future'],
  dataTypes: { // use hash for diff types depending on model
    futureTemp: ['temperature'],
    futureHumi: ['humidity'],
    futureDi: ['onoff'],
    futureGas: ['co2'],
    futurePower: ['power'],
    futureDust: ['dust'],
    futureCount: ['count'],
    futureCountEvent: ['countEvent'],
    futureVoltage: ['voltage'],
    futureCurrent: ['current'],
    futurePressure: ['pressure'],
  },
  onChange: {
    futureTemp: false,
    futureHumi: false,
    futureDi: true,
    futureGas: false,
    futurePower: false,
    futureDust: false,
    futureCount: false,
    futureCountEvent: true,
    futureVoltage: false,
    futureCurrent: false,
    futurePressure: false,
  },
  discoverable: true,
  recommendedInterval: {
    futureTemp: 10000,
    futureHumi: 30000,
    futureDi: 10000,
    futureGas: 10000,
    futurePower: 10000,
    futureDust: 10000,
    futureCount: 10000,
    futureCountEvent: 10000,
    futureVoltage: 10000,
    futureCurrent: 10000,
    futurePressure: 10000
  },
  validCachedValueTimeout: 7000,
  maxInstances: 1,
  models: ['futureTemp', 'futureHumi', 'futureDi', 'futureGas', 'futurePower', 
    'futureDust', 'futureCount', 'futureCountEvent', 'futureVoltage', 'futureCurrent', 'futurePressure'],
  category: 'sensor'
};

util.inherits(FutureSensor, Sensor);

FutureSensor.prototype._get = function (cb) {
  var self = this,
      rtn = { id: self.id};

  if (!this.session) {
    logger.error('futuresensor:_get no session', self.id, self.model);

    self.throttledChkSession();
    rtn.status = 'error';
    rtn.message = 'no session';
    if (cb) {
      return cb(new Error('no session'), rtn);
    } else {
      self.emit('data', rtn);
      return;
    }
  }
  
  //FIXME: this is redundant since throttledChkSession() is called eventually on error.
  logger.debug('_get', self.enableChange, 
    !self.dataListener, _.indexOf(self.device.listeners('change'), self.dataListener));
  if (self.device && self.enableChange &&
    (!self.dataListener || 
      _.indexOf(self.device.listeners('change'), self.dataListener) === -1)) {
    self.throttledChkSession();
  }

  snmpHelper.getSNMP(this.session, self.valueOid, function (err, result) {
    var value;

    if (!err && !_.isEmpty(result) && _.has(result, self.valueOid) && 
        (value = result[self.valueOid].toString()) !== 'N/A') {
      rtn.status = 'ok';
      rtn.result = {};
      //FIXME: correct server 
      if (value === 'ON') {
        value = 1;
      } else if (value  === 'OFF') {
        value = 0;
      }
      rtn.result[self.dataType] = value;
      logger.debug('data', rtn);
      if (cb) {
        return cb(null, rtn);
      } else {
        self.emit('data', rtn);
        return;
      }
    } else {
      self.throttledChkSession();

      rtn.status = 'error';
      if (value === 'N/A') {
        rtn.message = 'error value: N/A';
      } else {
        rtn.message = (err && err.toString()) || 'snmp get error';
      }
      logger.error('data', rtn);
      if (cb) {
        return cb(rtn.message, rtn);
      } else {
        self.emit('data', rtn);
        return;
      }
    }
  });
};


FutureSensor.prototype.checkDi = function(err, di) {
  var self = this,
      now = Date.now();

  if (err) {
    logger.error('change err', err, di);
    self.emit('change', di || {id: self.id, status: 'error', message: err.toString()});
  } else if (!di.result || _.isUndefined(di.result.onoff)) {
    logger.error('change invalid err', di);
    di.status = 'error';
    di.message = 'invalid value';
    self.emit('change', di);
  } else if (this._cached.value !== di.result.onoff) {
    di.status = 'ok';
    logger.debug('di change', di);
    self.emit('change', di);
    this._cached.value = di.result.onoff;
    this._cached.time = now;
  } else if (this._cached.time + REPORT_INTERVAL <= now) { //report status reguarilly
    logger.debug('di change, status only', di);
    self.emit('change', {id: self.id, status: 'ok'});
    //this._cached.value = di.result.onoff;
    this._cached.time = now;
  }
};

FutureSensor.prototype._enableChange = function () {
  var self = this;

  if (!FutureSensor.properties.onChange[self.model]) {
    throw new Error('enable change for non-event');
  }
  logger.debug('futureSensor:_enableChange', self.oid);

  self.enableChange = true;
  self.throttledChkSession();
  if (!self.timer) {
    self._get(self.checkDi.bind(self));
    self.timer = setInterval(function () {
      self._get(self.checkDi.bind(self));
    }, DI_POLLING_INTERVAL);
  }
};

FutureSensor.prototype._clear = function () {
  if (this.session) {
    this.session.close();
    delete this.session;
  }
  if (this.timer) {
    clearInterval(this.timer);
    delete this.timer;
  }
};

module.exports = FutureSensor;
