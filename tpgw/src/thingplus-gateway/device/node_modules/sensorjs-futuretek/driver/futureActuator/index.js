'use strict';
var util = require('util'),
    _ = require('lodash'),
    snmp = require ('net-snmp');

var SensorLib = require('../../index'),
    Actuator = SensorLib.Actuator,
    logger = Actuator.getLogger(),
    snmpHelper = require('../../snmpHelper'),
    cfg = snmpHelper.config;

var THROTTLE_INTERVAL = 60*1000;

function chkSession(self, cb) {
  var network = self.info && self.info.device && 
                self.info.device.sensorNetwork &&
                SensorLib.getNetwork(self.info.device.sensorNetwork),
      prevIp = self.ip;

  if (!network || !self.info.device.address) {
    logger.error('futureSensor:chkSession invalid device info', self.info);
    return cb && cb(new Error('invalid device info'));
  }
  network.getDevice(self.info.device.address, function (err, device) {
    var si;

    self.ip = device && device.extraInfo && device.extraInfo.ipAddr;

    if (!self.ip) {
      logger.error('futureSensor:chkSession missing device', self.info);
      return cb && cb(new Error('missing device'));
    }

    si = _.find(device.extraInfo && device.extraInfo.sensorInfos, {id: self.id});
    if (si && si.oid) {
      self.oidIdx = Number(si.oid.substring(si.oid.lastIndexOf('.') + 1));
    }
    if (!si || ((self.oidIdx !==0) && !self.oidIdx)) {
      logger.error('futureSensor: cannot find sensorinfo', self.id, self.oid);
    }

    if (self.ip === prevIp && self.session) {//no ip change keep session
      return cb && cb();
    } else { 
      logger.debug('futureSensor:chkSession ip change or no session:', self.id, prevIp, self.ip);
      if (self.session) {
        self.session.close();
        delete self.session;
      }
      self.session = snmp.createSession(self.ip, 'public', cfg.SNMP_OPTIONS);
      logger.warn('futureSensor:chkSession new session:', self.id, self.ip);
      return cb && cb();
    }
  });
}

function FutureActuator(sensorInfo, options) {
  Actuator.call(this, sensorInfo, options);
  if (sensorInfo.model) {
    this.model = sensorInfo.model;
  }
  var self = this;
  //future = sensorDriver.getNetwork('future');
  logger.debug('FutureActuator', sensorInfo);
  this.oidIdx = parseInt(this.id.slice(-2), 16); // FIXME: last 2 disits from id
  var sensor = _.find(cfg.SENSOR_OIDS, {model: this.model});
  this.baseOid = sensor &&  sensor.baseOid;
  this.valueOid = sensor && 
        [sensor.baseOid, cfg.VALUE_OID, this.oidIdx.toString(16)].join('.');
  this.dataType = _.first(FutureActuator.properties.dataTypes[this.model]);

  this.throttledChkSession = _.throttle(_.partial(chkSession, this), 
      THROTTLE_INTERVAL, {trailing: false});
  this.throttledChkSession();

  //polling until first session being established.
  function pollingFirstSession() {
    setTimeout(function () {
      if (!self.session) {
        chkSession();
        pollingFirstSession();
      }
    }, THROTTLE_INTERVAL);
  }
  pollingFirstSession();
}

FutureActuator.properties = {
  supportedNetworks: ['future'],
  dataTypes: {
    futureDo: ['powerSwitch'],
    futureTempCtrl: ['temperatureController'],
  },
  discoverable: true,
  addressable: false,
  maxInstances: 5,
  models: ['futureDo', 'futureTempCtrl'],
  commands: {
    futureDo: ['on', 'off'],
    futureTempCtrl: ['get', 'set'],
  },
  category: 'actuator'
};

util.inherits(FutureActuator, Actuator);

FutureActuator.prototype._set = function (cmd, options, cb) {
  var self = this, duration;

  switch (cmd) {
    case 'on':
      duration = options && Number(options.duration, 10);

      self._clearTimer();
      if (self.dataType !== 'powerSwitch') {
        return _.isFunction(cb) && 
        cb(new Error('Not supported model:' + self.dataType));
      }

      if (!duration || duration <= 0) {
        duration = 0; 
      }

      self.__set(1, function (err) {
        if (duration) {
          self.offTimer = setTimeout(function () {
            self.offTimer = null;
            logger.info('[futureActuator:__set] off after duration=', duration);
            self._set('off');
          }, duration);
        }
        return _.isFunction(cb) && cb(err, err ? null : self.id + ' is on');
      });
      break;

    case 'off':
      self._clearTimer();
      if (self.dataType !== 'powerSwitch') {
        return _.isFunction(cb) && 
        cb(new Error('Not supported model:' + self.dataType));
      }

      self.__set(0, function (err) {
        return _.isFunction(cb) && cb(err, err ? null : self.id + ' is off');
      });
    break;

  case 'set':
    self._clearTimer();
    if (self.dataType !== 'temperatureController') {
      return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + self.dataType));
    }

    self.__set(JSON.stringify(options), function (err, result) {
      return _.isFunction(cb) && cb(err, result);
    });
    break;

  case 'get':
    self._clearTimer();
    if (self.dataType !== 'temperatureController') {
      return _.isFunction(cb) && 
      cb(new Error('Not supported model:' + self.dataType));
    }

    self.__get(function (err, result) {
      return _.isFunction(cb) && cb(err, result);
    });
    break;

  default:
    return _.isFunction(cb) && cb(new Error('unknown cmd:' + cmd)); 
  }
};

FutureActuator.prototype.__set = function (value, cb) {
  var self = this,
    setVarbind = {
      oid: self.valueOid,
      type: snmp.ObjectType.OctetString,
      value: value.toString(),
    };

  if (!self.session) {
    self.throttledChkSession();
    logger.error('[futureActuator:__set]snmp session is not ready', self.id, self.model, self.ip);
    return cb && cb(new Error('snmp session is not ready'));
  }

  snmpHelper.setSNMP(self.session, [setVarbind], function (err, result) {
    if (!err) {
      logger.info('[futureActuator:__set] set val=', result && 
        result[self.valueOid] && result[self.valueOid].toString());
        return cb && cb(null, value);
    } else {
      self.throttledChkSession();
      logger.error('[futureActuator:__set]snmp set failure', err, result);
      return cb && cb(new Error('snmp set failure'));
    }
  });
  return;
};

FutureActuator.prototype.__get = function (cb) {
  var self = this;

  if (!self.session) {
    self.throttledChkSession();
    logger.error('[futureActuator:__get]snmp session is not ready', self.id, self.model, self.ip);
    return cb && cb(new Error('snmp session is not ready'));
  }

  snmpHelper.getSNMP(self.session, self.valueOid, function (err, result) {
    var rtn = result && 
        result[self.valueOid] && result[self.valueOid].toString();
    if (!err && rtn && rtn !== 'N/A') {
        logger.info('[futureActuator:__get] set val=', rtn);
        return cb && cb(null, rtn);
    } else {
      self.throttledChkSession();
      logger.error('[futureActuator:__get]snmp set failure', err, result);
      if (!err && rtn === 'N/A') {
        return cb && cb(new Error('N/A value'));
      } else {
        return cb && cb(new Error('snmp set failure'));
      }
    }
  });
  return;
};

FutureActuator.prototype._clearTimer = function () {
  if (this.blinkTimer) {
    clearInterval(this.blinkTimer);
    this.blinkTimer = null;
  }
  if (this.offTimer) {
    clearTimeout(this.offTimer);
    this.offTimer = null;
  }
};

FutureActuator.prototype._clear = function () {
  this._clearTimer();
  if (this.session) {
    this.session.close();
    delete this.session;
  }
  return;
};

module.exports = FutureActuator;
